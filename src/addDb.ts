import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export interface AddDbOptions {
  runMigration?: boolean;
  envPath?: string;
  silent?: boolean;
  dbName?: string;
  dbType?: 'sqlite' | 'postgresql' | 'mysql';
  migrationName?: string; // Custom migration name
}

export interface AddDbResponse {
  success: boolean;
  message: string;
  envPath?: string;
  databaseUrl?: string;
}

/**
 * üóÑÔ∏è ADD DATABASE FUNCTION
 * Creates .env file with database URL and optionally runs migrations
 * 
 * @param options - Configuration options for database setup
 * @returns Promise with database setup result
 */
export async function addDb(options: AddDbOptions = {}): Promise<AddDbResponse> {
  const {
    runMigration = true,
    envPath = '../.env', // ‚úÖ One level up from src/
    silent = false,
    dbName = 'zkauth',
    dbType = 'sqlite',
    migrationName = 'init'
  } = options;

  // Resolve absolute path for .env file (one level up from src/)
  const absoluteEnvPath = path.resolve(__dirname, envPath);

  try {
    if (!silent) {
      console.log("üóÑÔ∏è Setting up database configuration...");
      console.log("Database type:", dbType);
      console.log("Database name:", dbName);
      console.log("Env file path:", absoluteEnvPath);
    }

    // Step 1: Generate DATABASE_URL based on database type
    let databaseUrl: string;
    
    switch (dbType) {
      case 'sqlite':
        databaseUrl = `file:./${dbName}.db`;
        break;
      
      case 'postgresql':
        databaseUrl = `postgresql://username:password@localhost:5432/${dbName}?schema=public`;
        break;
      
      case 'mysql':
        databaseUrl = `mysql://username:password@localhost:3306/${dbName}`;
        break;
      
      default:
        throw new Error(`Unsupported database type: ${dbType}`);
    }

    if (!silent) {
      console.log("üìù Generated DATABASE_URL:", databaseUrl);
    }

    // Step 2: Create or update .env file
    const envContent = `# Database Configuration
# Generated by addDb function on ${new Date().toISOString()}

DATABASE_URL="${databaseUrl}"

# Prisma Configuration
PRISMA_CLI_QUERY_ENGINE_TYPE="binary"

# Optional: Add other environment variables here
# NODE_ENV="development"
# PORT="3000"
`;

    try {
      // Check if .env already exists
      let existingEnv = '';
      if (fs.existsSync(absoluteEnvPath)) {
        existingEnv = fs.readFileSync(absoluteEnvPath, 'utf8');
        
        // Check if DATABASE_URL already exists
        if (existingEnv.includes('DATABASE_URL=')) {
          if (!silent) {
            console.log("‚ö†Ô∏è DATABASE_URL already exists in .env file");
            console.log("üîÑ Updating existing DATABASE_URL...");
          }
          
          // Replace existing DATABASE_URL
          const updatedEnv = existingEnv.replace(
            /DATABASE_URL=.*$/m,
            `DATABASE_URL="${databaseUrl}"`
          );
          fs.writeFileSync(absoluteEnvPath, updatedEnv, 'utf8');
        } else {
          // Append to existing .env
          fs.appendFileSync(absoluteEnvPath, '\n' + envContent, 'utf8');
        }
      } else {
        // Create new .env file
        fs.writeFileSync(absoluteEnvPath, envContent, 'utf8');
      }

      if (!silent) {
        console.log("‚úÖ .env file created/updated at:", absoluteEnvPath);
      }

    } catch (envError) {
      console.error("‚ùå Error writing .env file:", envError);
      return {
        success: false,
        message: `Failed to create .env file: ${envError}`
      };
    }

    // Step 3: Create Prisma schema if it doesn't exist
    const schemaPath = path.resolve(__dirname, '../prisma/schema.prisma');
    if (!fs.existsSync(schemaPath)) {
      if (!silent) {
        console.log("üìã Creating Prisma schema...");
      }
      
      await createPrismaSchema(dbType, silent);
    }

    // Step 4: Run database migrations if requested
    if (runMigration) {
      if (!silent) {
        console.log("üîÑ Running database migrations...");
      }
      
      try {
        const projectRoot = path.resolve(__dirname, '..');
        
        // Generate Prisma client
        await execAsync('npx prisma generate', { cwd: projectRoot });
        if (!silent) {
          console.log("‚úÖ Prisma client generated");
        }

        // Run database migrations with dev mode
        await execAsync(`npx prisma migrate dev --name ${migrationName}`, { cwd: projectRoot });
        if (!silent) {
          console.log("‚úÖ Database migrations completed (migrate dev)");
        }

      } catch (migrationError) {
        console.error("‚ö†Ô∏è Migration warning:", migrationError);
        
        // Fallback to db push if migrate dev fails
        if (!silent) {
          console.log("üîÑ Trying fallback: npx prisma db push...");
        }
        
        try {
          const projectRoot = path.resolve(__dirname, '..');
          await execAsync('npx prisma db push', { cwd: projectRoot });
          if (!silent) {
            console.log("‚úÖ Database schema pushed successfully");
          }
        } catch (pushError) {
          console.error("‚ùå Both migrate dev and db push failed:", pushError);
          if (!silent) {
            console.log("üí° You can run migrations manually with:");
            console.log("   npx prisma migrate dev --name init");
            console.log("   or: npx prisma db push");
          }
        }
      }
    }

    if (!silent) {
      console.log("üéâ Database setup completed successfully!");
    }

    return {
      success: true,
      message: 'Database configuration created successfully',
      envPath: absoluteEnvPath,
      databaseUrl: databaseUrl
    };

  } catch (error: any) {
    console.error("‚ùå AddDb error:", error);
    return {
      success: false,
      message: `Database setup failed: ${error.message || 'Unknown error'}`
    };
  }
}

/**
 * üìã CREATE PRISMA SCHEMA
 * Creates a basic Prisma schema file with User model
 */
async function createPrismaSchema(dbType: string, silent: boolean = false) {
  // Create schema one level up from src/
  const schemaDir = path.resolve(__dirname, '../prisma');
  const schemaPath = path.join(schemaDir, 'schema.prisma');

  // Create prisma directory if it doesn't exist
  if (!fs.existsSync(schemaDir)) {
    fs.mkdirSync(schemaDir, { recursive: true });
  }

  const schemaContent = `// Prisma schema file
// Generated by addDb function

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "${dbType === 'sqlite' ? 'sqlite' : dbType}"
  url      = env("DATABASE_URL")
}

// User model for ZK authentication
model User {
  id     Int    @id @default(autoincrement())
  UserId String @unique
  hash   String
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}
`;

  fs.writeFileSync(schemaPath, schemaContent, 'utf8');
  
  if (!silent) {
    console.log("üìã Prisma schema created at:", schemaPath);
  }
}

/**
 * üîÑ STANDALONE MIGRATION FUNCTION
 * Runs Prisma migrations independently
 * 
 * @param migrationName - Name for the migration (default: 'update')
 * @param silent - Whether to suppress console output
 * @returns Promise with migration result
 */
export async function runDatabaseMigration(migrationName: string = 'update', silent: boolean = false): Promise<AddDbResponse> {
  try {
    if (!silent) {
      console.log("üîÑ Running Prisma migration...");
      console.log("Migration name:", migrationName);
    }

    const projectRoot = path.resolve(__dirname, '..');

    // Step 1: Generate Prisma client
    if (!silent) console.log("üì¶ Generating Prisma client...");
    await execAsync('npx prisma generate', { cwd: projectRoot });
    if (!silent) console.log("‚úÖ Prisma client generated");

    // Step 2: Run migration dev
    if (!silent) console.log("üöÄ Running migration dev...");
    const migrationCommand = `npx prisma migrate dev --name ${migrationName}`;
    await execAsync(migrationCommand, { cwd: projectRoot });
    
    if (!silent) {
      console.log("‚úÖ Migration completed successfully!");
      console.log("üìÅ Check prisma/migrations/ directory for migration files");
    }

    return {
      success: true,
      message: 'Migration completed successfully',
      databaseUrl: 'Migration applied to existing database'
    };

  } catch (error: any) {
    console.error("‚ùå Migration failed:", error);
    
    if (!silent) {
      console.log("üí° Try these manual commands:");
      console.log("   npx prisma generate");
      console.log(`   npx prisma migrate dev --name ${migrationName}`);
      console.log("   or: npx prisma db push");
    }

    return {
      success: false,
      message: `Migration failed: ${error.message || 'Unknown error'}`
    };
  }
}

/**
 * üß™ EXAMPLE USAGE FUNCTIONS
 */

// SQLite setup (default)
export async function setupSQLite(dbName: string = 'zkauth') {
  return await addDb({
    dbType: 'sqlite',
    dbName: dbName,
    runMigration: true,
    migrationName: 'init_zkauth'
  });
}

// PostgreSQL setup
export async function setupPostgreSQL(dbName: string = 'zkauth') {
  return await addDb({
    dbType: 'postgresql',
    dbName: dbName,
    runMigration: false, // Usually need to create DB first
    silent: false
  });
}

// MySQL setup
export async function setupMySQL(dbName: string = 'zkauth') {
  return await addDb({
    dbType: 'mysql',
    dbName: dbName,
    runMigration: false, // Usually need to create DB first
    silent: false
  });
}

/**
 * üß™ TEST FUNCTION
 */
export async function testAddDb() {
  console.log("=== TESTING DATABASE SETUP ===");
  
  try {
    const result = await setupSQLite('test_zkauth');
    console.log("Setup result:", result);
    
    if (result.success) {
      console.log("üéâ Database setup test successful!");
      console.log("üìÅ Check your .env file and prisma/ directory");
      
      // Test standalone migration
      console.log("\n=== TESTING STANDALONE MIGRATION ===");
      const migrationResult = await runDatabaseMigration('test_update');
      console.log("Migration result:", migrationResult);
      
    } else {
      console.error("‚ùå Database setup test failed:", result.message);
    }
    
  } catch (error) {
    console.error("‚ùå Test error:", error);
  }
}

// Export all functions
export default addDb;